<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MOVE Map</title>
  <!-- 본인 앱키로 교체 -->
  <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=fc1c450fc44c5cda47534a556fe9b4f2"></script>
  <style>html,body{margin:0;height:100%}#map{width:100%;height:100vh}</style>
</head>
<body>
  <div id="map"></div>
  <script>
    // ---------- 유틸 ----------
    function getParams() {
      const url = new URL(window.location.href);
      const params = new URLSearchParams(url.search);
      return {
        type: params.get("type") || "blank",
        payloadB64: params.get("payload") || ""
      };
    }
    function b64ToJson(b64) {
      if (!b64) return null;
      try {
        // Unicode 안전 base64 decode
        const str = decodeURIComponent(escape(atob(b64)));
        return JSON.parse(str);
      } catch (e) {
        console.error("payload decode 실패:", e);
        return null;
      }
    }
    function clamp(n, min, max){ return Math.max(min, Math.min(n, max)); }

    // ---------- 지도 초기화 ----------
    const center = new kakao.maps.LatLng(36.502306, 127.264738);
    const map = new kakao.maps.Map(document.getElementById("map"), {
      center: center,
      level: 4
    });

    const { type, payloadB64 } = getParams();
    const payload = b64ToJson(payloadB64);

    // 아무 것도 못 받았으면 끝
    if (!payload) {
      console.log("빈 payload → 기본 지도만 표시");
    } else {
      if (type === "points") {
        // payload: [{lat,lng,scaled_weight,station,weight}, ...]
        payload.forEach(p => {
          const size = Math.max(10, Math.min(60, Number(p.scaled_weight || 24)));
          const pos = new kakao.maps.LatLng(p.lat, p.lng);
          const img = new kakao.maps.MarkerImage(
            "http://t1.daumcdn.net/localimg/localimages/07/2018/pc/img/marker_spot.png",
            new kakao.maps.Size(size, size*1.35),
            { offset: new kakao.maps.Point(size/2, size*1.35) }
          );
          const marker = new kakao.maps.Marker({ position: pos, image: img, title: `${p.station}: ${p.weight}` });
          marker.setMap(map);
        });

      } else if (type === "routes") {
        // payload: { routes: [[{lat,lng,color},...], ...], pickups: [{lat,lng,onboardingTime,...}, ...] }
        const routes = payload.routes || [];
        const pickups = payload.pickups || [];

        routes.forEach(segList => {
          if (!Array.isArray(segList) || segList.length < 2) return;
          const color = segList[0].color || "#173F5F";
          const path = segList.map(pt => new kakao.maps.LatLng(pt.lat, pt.lng));
          const poly = new kakao.maps.Polyline({
            path,
            strokeWeight: 3,
            strokeColor: color,
            strokeOpacity: 0.9,
            strokeStyle: "shortdash"
          });
          poly.setMap(map);
        });

        pickups.forEach((p, idx) => {
          const pos = new kakao.maps.LatLng(p.lat, p.lng);
          const size = 30;
          const img = new kakao.maps.MarkerImage(
            "http://t1.daumcdn.net/localimg/localimages/07/2018/pc/img/marker_spot.png",
            new kakao.maps.Size(size, size*1.35),
            { offset: new kakao.maps.Point(size/2, size*1.35) }
          );
          const title =
            `탑승순서: ${idx+1}\n탑승시간: ${p.onboardingTime}\n승객 수: ${p.passengerCount}\n휠체어 수: ${p.wheelchairCount}\n서비스 유형: ${p.serviceType}`;
          new kakao.maps.Marker({ position: pos, image: img, title }).setMap(map);
        });

      } else if (type === "links") {
        // payload: [{start_lat,start_lon,end_lat,end_lon,count}, ...]
        if (!Array.isArray(payload) || payload.length === 0) {
          console.log("links payload empty");
        } else {
          const counts = payload.map(r => r.count || 0);
          const minC = Math.min(...counts), maxC = Math.max(...counts);
          const scale = v => {
            if (maxC === minC) return 10;
            const t = (v - minC) / (maxC - minC);
            return Math.round(5 + t*(30-5));
          };
          const alpha = v => {
            if (maxC === minC) return 0.8;
            const t = (v - minC) / (maxC - minC);
            return clamp(0.5 + t*(1.0-0.5), 0.4, 1.0);
          };

          payload.forEach(r => {
            const path = [
              new kakao.maps.LatLng(r.start_lat, r.start_lon),
              new kakao.maps.LatLng(r.end_lat, r.end_lon)
            ];
            new kakao.maps.Polyline({
              path,
              strokeWeight: scale(r.count),
              strokeColor: "#002642",
              strokeOpacity: alpha(r.count),
              strokeStyle: "solid"
            }).setMap(map);
          });
        }

      } else if (type === "polygons") {
        // payload: GeoJSON FeatureCollection (features[].geometry.coordinates[0] = [lon,lat] 배열)
        const fc = payload;
        if (fc && fc.type === "FeatureCollection" && Array.isArray(fc.features)) {
          fc.features.forEach(f => {
            const coords = (((f||{}).geometry||{}).coordinates||[])[0];
            if (!Array.isArray(coords)) return;
            const path = coords.map(c => new kakao.maps.LatLng(c[1], c[0]));
            const op = clamp(Number((((f||{}).properties||{}).opacity_value)||0.5), 0, 1);
            new kakao.maps.Polygon({
              path,
              strokeWeight: 1,
              strokeColor: "#000000",
              strokeOpacity: 0.1,
              fillColor: "#ED553B",
              fillOpacity: op
            }).setMap(map);
          });
        }
      } else {
        console.log("알 수 없는 type:", type);
      }
    }

    const myOrigin = location.origin;
  
    // 2) 타입별 드로잉 함수 (기존 코드의 블록을 함수화해서 호출해도 되고,
    //    아래처럼 payload를 그대로 기존 로직에 넣어 호출해도 됩니다.)
    function drawPoints(payload) {
      // payload: { center, level, locations: [...] }
      if (!payload || !Array.isArray(payload.locations)) return;
      payload.locations.forEach(p => {
        const size = Math.max(10, Math.min(60, Number(p.scaled_weight || 24)));
        const pos = new kakao.maps.LatLng(p.lat, p.lng);
        const img = new kakao.maps.MarkerImage(
          "http://t1.daumcdn.net/localimg/localimages/07/2018/pc/img/marker_spot.png",
          new kakao.maps.Size(size, size*1.35),
          { offset: new kakao.maps.Point(size/2, size*1.35) }
        );
        new kakao.maps.Marker({ position: pos, image: img, title: `${p.station}: ${p.weight}` }).setMap(map);
      });
    }
  
    function drawRoutes(payload) {
      // payload: { center, level, routes: [{path:[{lat,lng}...], color, weight, opacity, style}], pickups:[...] }
      (payload.routes || []).forEach(seg => {
        const path = (seg.path || []).map(pt => new kakao.maps.LatLng(pt.lat, pt.lng));
        new kakao.maps.Polyline({
          path,
          strokeWeight: seg.weight || 3,
          strokeColor: seg.color || "#173F5F",
          strokeOpacity: seg.opacity ?? 0.9,
          strokeStyle: seg.style || "shortdash"
        }).setMap(map);
      });
      (payload.pickups || []).forEach((p, i) => {
        const pos = new kakao.maps.LatLng(p.lat, p.lng);
        const size = 30;
        const img = new kakao.maps.MarkerImage(
          "http://t1.daumcdn.net/localimg/localimages/07/2018/pc/img/marker_spot.png",
          new kakao.maps.Size(size, size*1.35),
          { offset: new kakao.maps.Point(size/2, size*1.35) }
        );
        const title = `탑승순서: ${i+1}\n탑승시간: ${p.onboardingTime}\n승객 수: ${p.passengerCount}\n휠체어 수: ${p.wheelchairCount}\n서비스 유형: ${p.serviceType}`;
        new kakao.maps.Marker({ position: pos, image: img, title }).setMap(map);
      });
    }
  
    function drawLinks(payload) {
      // payload: { links: [{start_lat,start_lon,end_lat,end_lon,weight,opacity,color}, ...] }
      (payload.links || []).forEach(r => {
        const path = [
          new kakao.maps.LatLng(r.start_lat, r.start_lon),
          new kakao.maps.LatLng(r.end_lat, r.end_lon),
        ];
        new kakao.maps.Polyline({
          path,
          strokeWeight: r.weight || 8,
          strokeColor: r.color || "#002642",
          strokeOpacity: r.opacity ?? 0.8,
          strokeStyle: "solid"
        }).setMap(map);
      });
    }
  
    function drawPolygons(payload) {
      // payload: { features: Feature[] }
      (payload.features || []).forEach(f => {
        const coords = (((f||{}).geometry||{}).coordinates||[])[0];
        if (!Array.isArray(coords)) return;
        const path = coords.map(c => new kakao.maps.LatLng(c[1], c[0]));
        const op = Math.max(0, Math.min(1, Number((((f||{}).properties||{}).opacity_value)||0.5)));
        new kakao.maps.Polygon({
          path,
          strokeWeight: 1,
          strokeColor: "#000000",
          strokeOpacity: 0.1,
          fillColor: "#ED553B",
          fillOpacity: op
        }).setMap(map);
      });
    }
  
    // 3) postMessage 수신부
    window.addEventListener("message", (e) => {
      const data = e.data || {};
      if (!data.type) return;
  
      if (data.type === "SET_MARKERS") {
        drawPoints(data.payload || {});
      } else if (data.type === "SET_ROUTES") {
        drawRoutes(data.payload || {});
      } else if (data.type === "SET_LINKS") {
        drawLinks(data.payload || {});
      } else if (data.type === "SET_GEOJSON") {
        drawPolygons(data.payload || {});
      }
    });
  
    // 4) 로드되면 부모에게 준비완료 신호
    try {
      window.parent.postMessage({ type: "MAP_READY" }, "*");
    } catch (e) {
      console.warn("MAP_READY 보내기 실패:", e);
    }
  

    
  </script>
</body>
</html>
